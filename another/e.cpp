/*

Группа туристов планирует поход по горной местности. На карте отмечены N мест
для привала и M тропинок, соединяющих места для ночлега. Каждая тропинка,
соединяющая места для ночлега (і, j), характеризуется временем в часах t_i,j,
необходимым для перемещения по ней. Перемещение по тропинке возможно в любом
направлении, время перемещения в обе стороны одинаково.

В связи с физическими возможностями группы, в день туристы могут находиться в
пути не более D часов. При этом за один день можно пройти по нескольким тропинкам,
если суммарная продолжительность перемещения по ним не превышает D часов. Ночевать
туристы могут только в отмеченных местах для ночлега.

Требуется определить, за какое минимальное количество дней группа сможет добраться
из места с номером А в место с номером В.

Формат ввода
Первая строка содержит четыре целых числа: N (2≤N≤1000) — количество мест для ночлега,
М (1≤М≤1000) — количество тропинок, А и В (1 ≤ A,B < N, A ≠ B) - начальный и конечный пункты маршрута.

Вторая строка содержит целое число D (1≤D<10^9) — максимальное количество часов,
которое туристы могут провести в пути за один день.

Следующие М строк содержат по три целых числа: u_i, v_i, t_i
(1 ≤ u_i, v_i < N; u_i ≠ v_i; 1 < t_i < D) - описание переходов:
номера мест для привала на концах тропинки и время в часах для её преодоления.


Пример 1
Ввод
4 3 1 4
15
1 2 10
2 3 12
3 4 8

Вывод
3



Пример 2
Ввод
5 4 1 5
7
1 2 4
2 3 6
3 4 3
4 5 5

Вывод
4



Пример 3
Ввод
5 4 1 5
6
1 2 6
2 3 4
3 4 3
1 3 5

Вывод
-1

*/


#include <iostream>
#include <queue>
#include <unordered_set>

struct item {
  int num;              // номер места для привала.
  int days, lastHours;  // количество дней и остаток часов для того, чтобы достичь этого места привала.

  std::unordered_set<int> visited;  // номера посещённых привалов.

  item(int num, int days, int lastHours) : num(num), days(days), lastHours(lastHours) {}
  item(int num, int days, int lastHours, const std::unordered_set<int>& visited) : num(num), days(days), lastHours(lastHours), visited(visited) {}
};


// time: O(n*m)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);

  int n, m, a, b, d;
  std::cin >> n >> m >> a >> b >> d;

  --a; --b; // перевод номеров привалов в индексы.

  // Граф мест привалов, graph[i][j] == graph[j][i].
  // Если между местами привалов i и j существует тропа, 
  // которая занимает t часов, то graph[i][j] == graph[j][i] = t.
  // Если между местами привалов i и j НЕ существует тропы, то graph[i][j] == graph[j][i] = 0.
  int** graph = new int*[n];
  for (int i = 0; i < n; ++i) graph[i] = new int[n]{};
  
  // Ввод и заполнения графа.
  int u, v, t;
  for (int i = 0; i < m; ++i) {
    std::cin >> u >> v >> t;
    graph[u-1][v-1] = t;
    graph[v-1][u-1] = t;
  }
  
  int res = -1;        // количество дней, чтобы прийти из места A в B.
  std::queue<item> q;  // текущее расположение туристов.
  q.emplace(a, 1, d);  // добавление точки старта (пункт A).
  
  while (!q.empty()) {
    const item& node = q.front();  // текущее расположение туристов.
    
    // Если существует более короткий маршрут.
    if (res != -1 && res <= node.days) {
      q.pop();
      continue;
    }

    // Если туристы добрались до места назначения (пункт B).
    if (node.num == b) {
      res = node.days;
      q.pop();
      continue;
    }

    // Обход по каждой трапинки.
    for (int i = 0; i < n; ++i) {
      // Если тропа существует и туристы ещё не были в следующем лагере.
      if (graph[node.num][i] && node.visited.find(i) == node.visited.end()) {
        // Добавить новый маршрутю
        item& newNode = q.emplace(i, node.days, node.lastHours - graph[node.num][i], node.visited);

        // Если туристы не могут дойти до лагеря в тот же день.
        if (newNode.lastHours < 0) {
          ++newNode.days;                              // увеличить количество дней.
          newNode.lastHours = d - graph[node.num][i];  // обновить оставшееся время в дне.
        }

        newNode.visited.insert(i);  // запоминание посещения лагеря.
      }
    }
    
    q.pop();
  }
  
  std::cout << res << '\n';

  for (int i = 0; i < n; ++i) delete[] graph[i];
  delete[] graph;

  return 0;
}
