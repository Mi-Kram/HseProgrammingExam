/*
Тимону и Пумбе поручили нарисовать картину к празднику. Они еще не придумали,
что они будут рисовать, но уже поняли, что картина должна быть необычайно красивой.

Поэтому они решили, для начала, заказать специальные краски. Краски имеют цвет,
он задается тремя числами r, g и b (0≤r,g,b<256). Тимон и Пумба — очень странные
ребята. Они считают картину, в которой много очень разных цветов, некрасивой.
Поэтому, чем меньше max_i,j(max{∣r_i − r_j∣, ∣g_i − g_j∣, ∣b_i − b_j∣}), где
r_i, g_i, b_i — цвета, характеризующие краску, которая была использована во
время разрисовки), тем более, на их взгляд, картина красива.

Тимон и Пумба вынуждены экономить, поэтому они посчитали, что им нужно ровно k
различных красок, чтобы раскрасить скалу.

Нужно выбрать такие k цветов, чтобы нарисованная картина была как можно красивее.

Формат ввода
В первой строке заданы два натуральных числа n и k (1≤k,n≤10^5, k≤n).

В следующих n строках заданы цвета красок в тюбиках, по три числа в строке
r_i, g_i, b_i (0 ≤ r_i, g_i, b_i < 256).

Формат вывода
В единственной строке через пробел выведите k различных чисел — номера тюбиков,
которые требуется выбрать, чтобы нарисовать как можно более красивую картину.

Тюбики нумеруются в том порядке, в котором они заданы во входном файле.

Если есть несколько ответов на задачу, выведите любой.

Пример 1
Ввод
2 2
255 255 255
0 0 0

Вывод
2 1


Пример 2
Ввод
4 2
255 255 0
255 0 255
0 255 255
255 255 255

Вывод
3 2
*/

#include <algorithm>
#include <iostream>
#include <unordered_set>

struct node {
  int r, g, b;
};

struct edge {
  int node1, node2, dist;
};

int dist(const node& a, const node& b) {
  return std::max({std::abs(a.r - b.r), std::abs(a.g - b.g), std::abs(a.b - b.b)});
}

bool compare(const edge& a, const edge& b) {
  return a.dist < b.dist;
}

// time: O(n^2 * log(n))
int main() {
  int n, k;
  std::cin >> n >> k;

  node* nodes = new node[n];                // тюбики краски
  edge* edges = new edge[n * (n - 1) / 2];  // дистаниция между тюбиками (полный граф).
  int edgesCnt = 0;

  // Ввод данных.
  for (int i = 0; i < n; ++i) {
    // Новый тюбик краски.
    std::cin >> nodes[i].r >> nodes[i].g >> nodes[i].b;

    // Добавление рёбер между новым тюбиком краски и ранне добавленными тюбиками.
    for (int j = 0; j < i; ++j) {
      edges[edgesCnt].node1 = i;
      edges[edgesCnt].node2 = j;
      edges[edgesCnt].dist = dist(nodes[i], nodes[j]);
      ++edgesCnt;
    }
  }

  // Сортируем дистанцию между тюбиками.
  std::sort(edges, edges + edgesCnt, compare);

  // Добавляем вершины, пока не соберём k тюбиков.
  std::unordered_set<int> set;
  for (int i = 0; i < edgesCnt; ++i) {
    set.insert(edges[i].node1);
    if (set.size() == k) break;

    set.insert(edges[i].node2);
    if (set.size() == k) break;
  }
  
  // Ответ.
  for (int node : set) std::cout << node + 1 << ' ';
  std::cout << '\n';

  delete[] nodes;
  delete[] edges;

  return 0;
}
